# Shell 教程 #

- [1. Shell变量](#1-shell变量)
	- [1.1. 使用变量](#11-使用变量)
	- [1.2. 只读变量](#12-只读变量)
	- [1.3. 删除变量](#13-删除变量)
- [2. Shell字符串](#2-shell字符串) 
	- [2.1. 单引号](#21-单引号)
	- [2.2. 双引号](#22-双引号)
	- [2.3. 拼接字符串](#23-拼接字符串)
	- [2.4. 获取字符串长度](#24-获取字符串长度)
	- [2.5. 提取子字符串](#25-提取子字符串)
	- [2.6. 查找子字符串](#26-查找子字符串)
- 3. Shell数组
	- 3.1. 定义数组
	- 3.2. 读取数组
	- 3.3. 获取数组的长度
- 4. Shell注释
- 5. 参数传递
- 6. Shell运算符


## 1. Shell变量

定义变量时，变量名不加 $ 符号，如：

	your_name="myname"

`注意：变量名和等号之间不能有空格，而且不能使用 bash 里边的关键字（使用 bash --help 查看bash命令的保留关键字）`

### 1.1. 使用变量
	
	your_name="tom"
	echo $your_name
	echo ${your_name}

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如：

	echo "I am good at ${skill}Script"

像上边的括号的作用是为了告诉解释器 skill 是一个变量，如果不加 {} 解释器会把 skillScript 当作变量名来解析，推荐给所有变量加上花括号，这个类似于PHP的变量解释

已经定义过的变量可以被重新定义，如：

	your_name="tom"
	echo $your_name
	your_name="alibaba"
	echo $your_name

`注意：第二次赋值的时候不能写 $your_name="alibaba"，shell脚本只有在使用变量的时候才加 $ 符号，这是和PHP脚本的区别`

### 1.2. 只读变量

使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。
	
	myname="self"
	readonly myname
	myname="selfs"

运行脚本，会报错：

	./test.sh: line 4: myname: readonly variable
	
`注意：也可以简单的直接在定义变量的时候指定可读性 readonly myname="self"`

### 1.3. 删除变量

使用 unset 命令可以删除变量。语法：

	unset variable_name

### 1.4. 变量类型

运行shell时，会同时存在三种变量：
- **局部变量**：局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量。
- **环境变量**：所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保存其正常运行。必要的 shell 脚本也可以定义环境变量。
- **shell变量**：shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行

## 2. Shell字符串

字符串是 shell 脚本中最常用最有用的数据类型，字符串可以用单引号，也可以用双引号，也不可以不用引号。单双引号的区别跟 PHP 类似

### 2.1. 单引号

	str='this is a string'

单引号字符串的限制：
- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的
- 单引号字符串中不能出现单引号（对单引号使用转义符后也不行）

### 2.2. 双引号

	your_name='qin'
	str="hello, I konw your are \"$your_name\"! \n"

双引号的优点：
- 双引号里可以有变量
- 双引号里可以出现转义字符（转义字符可以参考PHP转义字符）

### 2.3. 拼接字符串

	var1="myname"
	var2="yourname"
	echo var1 var2

`注意：拼接变量的时候中间用空格隔开`

### 2.4. 获取字符串长度

	string="abcd"
	echo ${#string}

### 2.5. 提取子字符串

	string="runoob is a great company"
	echo ${string:1:4}

以上脚本输出： unoo

### 2.6. 查找子字符串

	string="runoob is a great company"
	echo `expr index "$string" is`

注意：以上脚本中是开头是 反引号，而不是 单引号

## 3. Shell数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小

类似C语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0

### 3.1. 定义数组

在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：

	数组名=(值1 值2 ... 值n)

例如：

	array_name=(value0 value1 value2)

或者：

	array_name=(
	value0
	value1
	)

还可以单独定义数组的各个分量：

	array_name[0]=value0
	array_name[1]=value1

可以不使用连续的下标，而且下标的范围没有限制，只要大于等于零

### 3.2. 读取数组

读取数组元素的一般格式是：

	${数组名[下标]}

例如：

	value0=${array_name[0]}

使用 @ 符号可以获取数组中的所有元素，例如：

	echo ${array_name[@]}

### 3.3. 获取数组的长度
	
获取数组长度的方法与获取字符串长度的方法相同，例如：

	# @ 或 * 可以获取数组中的所有元素
	# 取得数组元素的个数
	length=${#array_name[@]}
	# 或
	length=${#array_name[*]}
	# 取得数组单个元素的长度（索引为零的元素）
	length=${#array_name[0]}

## 4. Shell注释

以 # 开头的行就是注释，会被解释器忽略
sh 里没有多行注释，只能每一行加一个 # 号

	#--------------------------------------------
	# 这是一个注释
	#--------------------------------------------
	##### 用户配置区 开始 #####
	#
	#
	# 这里可以添加脚本描述信息
	# 
	#
	##### 用户配置区 结束  #####

## 5. 参数传递

我们可以在执行 Shell脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n代表一个数字，0为执行的文件名，1为执行脚本的第一个参数，2为执行脚本的第二个参数，以此类推

脚本内容 test.sh

	#!/bin/bash
	
	echo "Shell 传递参数实例！";
	echo "执行的文件名：$0";
	echo "第一个参数为：$1";
	echo "第二个参数为：$2";
	echo "第三个参数为：$3";

执行脚本：
	
	chmod +x test.sh
	./test.sh 1 2 3
	Shell 传递参数实例！
	执行的文件名：./test.sh
	第一个参数为：1
	第二个参数为：2
	第三个参数为：3

另外，还有几个特殊字符用来处理参数：

| 参数处理 | 说明 |
| --------| ---- |
|   `$#`  | 传递到脚本的参数个数 |
|   `$*`  | 以一个单字符串显示所有向脚本传递的参数，如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。|
|   `$$`  | 脚本运行的当前进程ID号 |
|   `$!`  | 后台运行的最后一个进程的ID号     |
|   `$@`  | 与 $* 相同，但是使用时加引号，并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
|   `$-`  | 显示Shell使用的当前选项，与Linux set命令功能相同 |
|   `$?`  | 显示最后命令的退出状态。0表示没有错误，其他任何值表面有错误 |

脚本内容 test.sh

	#!/bin/bash
	
	echo "Shell 传递参数实例！";
	echo "第一个参数为：$1";
	
	echo "参数个数为：$#";
	echo "传递的参数作为一个字符串显示：$*";

执行脚本：
	
	chmod +x test.sh
	./test.sh 1 2 3
	Shell 传递参数实例！
	第一个参数为：1
	参数个数为：3
	传递的参数作为一个字符串显示：1 2 3

**$* 与 $@ 区别**：
- 相同点：都是引用所有参数。
- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

下边使用循环输出参数来进行对比

脚本内容 test.sh

	#!/bin/bash
	
	echo "-- \$* 演示 ---"
	for i in "$*"; do
	    echo $i
	done
	
	echo "-- \$@ 演示 ---"
	for i in "$@"; do
	    echo $i
	done

执行脚本：
	
	chmod +x test.sh
	./test.sh 1 2 3
	-- $* 演示 ---
	1 2 3
	-- $@ 演示 ---
	1
	2
	3

可以看出用 $* 接收参数是作为一个变量，用 $@ 接收参数是作为一个数组

## 6. Shell运算符

Shell支持的运算符：

- 算数运算符
- 关系运算符
- 布尔运算符
- 字符串运算符
- 文件测试运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
expr 是一款表达式计算工具，使用它能完成表达式的求值操作。
例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：

	#!/bin/bash
	
	val=`expr 2 + 2`
	echo "两数之和为 : $val"

**两点注意**：

- 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
- 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。

### 6.1. 算术运算符

|运算符	|说明|	举例|
|------ |------| ------|
| +	|加法	|`expr $a + $b` 结果为 30。|
| -	|减法	|`expr $a - $b` 结果为 -10。|
| * | 乘法	|`expr $a \* $b` 结果为  200。|
| /	|除法	|`expr $b / $a` 结果为 2。|
| %	|取余	|`expr $b % $a` 结果为 0。|
| =	|赋值	|a=$b 将把变量 b 的值赋给 a。|
| == |	相等。用于比较两个数字，相同则返回 true。|	[ $a == $b ] 返回 false。|
| != |	不相等。用于比较两个数字，不相同则返回 true。|	[ $a != $b ] 返回 true。|

`注意：条件表达式要放在方括号之间，并且要有空格，例如：[$a==$b] 是错误的，必须写成 [ $a == $b ]`

算术运算实例：

	#!/bin/bash
	
	a=10
	b=20
	# 求和
	val=`expr $a + $b`
	echo "a + b : $val"
	# 求差
	val=`expr $a - $b`
	echo "a - b : $val"
	# 求积，注意 * 号要进行转义
	val=`expr $a \* $b`
	echo "a * b : $val"
	# 求商
	val=`expr $b / $a`
	echo "b / a : $val"
	# 求余
	val=`expr $b % $a`
	echo "b % a : $val"
	# 条件语句
	if [ $a == $b ]
	then
	   echo "a 等于 b"
	fi

	if [ $a != $b ]
	then
	   echo "a 不等于 b"
	fi

执行脚本，输出结果如下所示：

	a + b : 30
	a - b : -10
	a * b : 200
	b / a : 2
	b % a : 0
	a 不等于 b

**注意**：
- 乘号(*)前边必须加反斜杠(\)才能实现乘法运算；
- if...then...fi 是条件语句，后续将会讲解。
- 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 "*" 不需要转义符号 "\" 。

### 6.2. 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

|运算符	| 说明	| 举例|
|------|-------|-------|
|-eq	|检测两个数是否相等，相等返回 true。	|[ $a -eq $b ] 返回 false。|
|-ne	|检测两个数是否相等，不相等返回 true。	|[ $a -ne $b ] 返回 true。|
|-gt	|检测左边的数是否大于右边的，如果是，则返回 true。	|[ $a -gt $b ] 返回 false。|
|-lt	|检测左边的数是否小于右边的，如果是，则返回 true。	|[ $a -lt $b ] 返回 true。|
|-ge	|检测左边的数是否大于等于右边的，如果是，则返回 true。	|[ $a -ge $b ] 返回 false。|
|-le	|检测左边的数是否小于等于右边的，如果是，则返回 true。	|[ $a -le $b ] 返回 true。|

实例

关系运算符实例如下：

	#!/bin/bash
	
	a=10
	b=20
	
	if [ $a -eq $b ]
	then
	   echo "$a -eq $b : a 等于 b"
	else
	   echo "$a -eq $b: a 不等于 b"
	fi
	if [ $a -ne $b ]
	then
	   echo "$a -ne $b: a 不等于 b"
	else
	   echo "$a -ne $b : a 等于 b"
	fi
	if [ $a -gt $b ]
	then
	   echo "$a -gt $b: a 大于 b"
	else
	   echo "$a -gt $b: a 不大于 b"
	fi
	if [ $a -lt $b ]
	then
	   echo "$a -lt $b: a 小于 b"
	else
	   echo "$a -lt $b: a 不小于 b"
	fi
	if [ $a -ge $b ]
	then
	   echo "$a -ge $b: a 大于或等于 b"
	else
	   echo "$a -ge $b: a 小于 b"
	fi
	if [ $a -le $b ]
	then
	   echo "$a -le $b: a 小于或等于 b"
	else
	   echo "$a -le $b: a 大于 b"
	fi

执行脚本，输出结果如下所示：

	10 -eq 20: a 不等于 b
	10 -ne 20: a 不等于 b
	10 -gt 20: a 不大于 b
	10 -lt 20: a 小于 b
	10 -ge 20: a 小于 b
	10 -le 20: a 小于或等于 b