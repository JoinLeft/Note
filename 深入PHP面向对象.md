# 深入PHP面向对象

## 目录

- [1. 高级特性](#1-高级特性)
	- [1.1 静态方法和属性](#11-静态方法和属性)
	-  

## **1. 高级特性**

## 1.1 静态属性和方法

关于 static 关键字

静态方法是类作为作用域的函数。静态方法不能访问这个类中的普通属性，因为那些属性属于一个对象，但可以访问静态属性。如果修改了一个静态属性，那么这个类的所有实例都能访问到这个新值。

因为通过类而不是实例来访问静态元素，所以访问静态元素时不需要引用对象的变量，而是使用 :: (两个冒号)来连接类名和属性或者类名和方法。

MyClass::$MY_NAME
MyClass::createName($name);

要从当前类中访问静态方法或属性，可以使用 self 关键字。self 指向当前类，就像伪变量 $this 指向当前对象的实例一样。因此 StaticExample 类的外部可以使用其类名访问属性

StaticExample::$aNum;

而 StaticExample 类内部，可以使用self关键字：
class StaticExample {
static public $aNum = 0;
static public funtion sayHello(){
echo self::$aNum;
}
}

`注解：只有在使用 parent 关键字调用方法的时候，才能对一个非静态方法进行静态形式的调用（两个冒号）。除非是访问一个被覆写的方法，否则永远只能使用 :: 访问被声明为static的方法或属性。`

既然类中无法调用静态方法或属性，我们为什么要使用静态方法或属性呢？因为静态元素有很多有用的特性。首先我们在代码中的任何地方都可用。也就是说，你不需要在对象间传递类的实例，也不需要将实例存在在全局变量中，就可以访问类中的方法。其实，类的每个实例可以访问类中定义的静态属性而且每个实例访问到的值一样，所以你可以利用静态属性来设置值，该值可以被类的所有对象使用。最后，不需要实例对象就能访问静态属性或者静态方法，这样就不用为了获取一个简单的功能而实例话对象

## 1.2 常量属性

const 定义在类中的常量，所以又叫常量属性，只包好基本的数据类型的值，而且无法修改。像静态属性一样只能通过类而不能通过类的实例访问常量属性。常量一般全部大写

ShopProduct::WEB_URL;

当需要在类的所有实例中都能访问某个属性，并且属性值无需改变时，应该使用常量。

## 1.3 抽象类

抽象类不能被直接实例化，抽象类中只定义子类需要的方法。子类可以继承它并通过实现其中的抽象方法，是抽象类具体化。

```php
abstract class ShopProductWrite {
    protected $products = array();
    public function addProduct(ShopProduct $shopProduct) {
        $this->products[] = $shopProduct;
    }
}
```

和普通类一样，可以创建抽象类的方法和属性。但是切记不能实例化抽象类

$writer = new ShopProductWrite(); 这样是会报错的

大多数情况下，抽象类至少包含一个抽象方法。抽象方法用abstract关键字声明，其中不能有具体内容。你可以像声明普通类方法那样声明抽象方法，但要以分号而不是方法体结束，下边是添加了一个抽象方法 write()

```php
abstract class ShopProductWrite {
    protected $products = array();
    public function addProduct(ShopProduct $shopProduct) {
        $this->products[] = $shopProduct;
    }
    //抽象方法
    abstract public function write();
}
```

创建抽象方法后，要确保所有子类中都实现了该方法，但是实现细节可以先不确定.
如果像下面这样创建了一个继承自 ShopProductWrite 的类，但是不实现 write(),php会报致命错误

class ErroredWriter extends ShopProductWriter{}

所以,抽象类的每个子类都必须实现抽象类中的所有抽象方法，或者把它们自身也声明为抽象方法。扩展类不仅仅负责简单实现抽象类中的方法，还必须重新声明方法。新的实现方法的访问控制不能比抽象方法的访问控制更严格。新的实现方法的参数个数应该和抽象方法的参数个数一样，重新生成对应的类型提示。

```php
class XmlProductWrite extends ShopProductWrite{
    public function write()
    {
        // TODO: Implement write() method.
		//可以在这里边实现任何想实现的东西
    }
}
```

## 1.4 接口

抽象类提供了具体实现的标准，而接口则是纯粹的模板。接口只能定义功能而不包含实现的内容。接口可以用关键字 interface 来声明。接口可以包含属性和方法，但是方法体为空。

interface MyInter {
public function getPrice();
}

接口和类非常相似。任何实现接口的类都要实现接口中定义的所有方法，否则该类必须声明为 abstract

一个类可以在声明中使用 implements 关键字来实现某个接口。这么做之后，实现接口的具体过程和扩展一个仅包含抽象方法的抽象类是一样的。

class ShopProduct implements MyInter {
public function getPrice(){
....
}
}

## 1.5 延迟静态绑定：new static()

静态方法可以用作工厂方法，工厂方法是生成包含类的实例的一种方法

```php
abstract class DomainObject {
}
class User extends DomainObject {
    public static function create() {
        return new User();
    }
}
class Document extends DomainObject {
    public static function create() {
        return new Document();
    }
}
```

在编程过程中经常会遇到上边这种代码，子类的两个静态方法的作用是一样的，这时你可能会想把这个方法放到父类来实现，得到下边的代码

```php
abstract class DomainObject {
    public static function create() {
        return new self();
    }
}
class User extends DomainObject {
}
class Document extends DomainObject {
}
Document::create();
```

看起来是简洁不少，但是抽象父类的方法中返回的 self() 是作为对该类自身的引用。也就是你想用 self() 来实例化 DomainObject 抽象类， 但是实际上你想让他解析为 self 当前子类的实例，这时候可以使用 `延迟静态绑定`。该特性最明显的标志就是关键字 static。static 类似于 self，但它指的是被调用的类而不是包含类。在本例中，它的意思是调用 Document::create() 将生成一个 Document 对象，而不是试图实例化一个 DomainObject 对象
因此，现在在静态上下文中使用继承关系。

```php
abstract class DomainObject {
    public static function create() {
		/*
		static() static - PHP 5.3加进来的只得是当前这个类，有点像$this的意思，从堆内存中提取出来，访问的是当前实例化的那个类，那么 static 代表的就是那个类。
		*/
        return new static();
    }
}
class User extends DomainObject {
}
class Document extends DomainObject {
}
print_r(Document::create());
//输出 Document Object ( )
```

static关键字不仅仅可以用于实例化。和self和parent一样，static 还可以作为静态方法调用通用的标识符，甚至是从非静态上下文中调用。假设我想为 DomainOject 引入组的概念。默认情况下，所有类都属于default类别，但我想能为继承层次结构的某些分支重写类别。

```php
abstract class DomainObject {
    private $group;
    public function __construct()
    {
        $this->group = static::getGroup();
    }

    public static function create() {
        return new static();
    }

    static function getGroup() {
        return "default";
    }
}
class User extends DomainObject {
}
class Document extends DomainObject {
    static function getGroup()
    {
        return 'Document Class'; // TODO: Change the autogenerated stub
    }
}
class SpreaSheet extends Document {
}
print_r(User::create());
print_r(SpreaSheet::create());

//输出 User Object ( [group:DomainObject:private] => default ) 
//输出 SpreaSheet Object ( [group:DomainObject:private] => Document Class )
```

user 类不需要实现太多功能。DomainOjbect 构造函数调用了 getGroup 类，并在本地进行查找。对于SpreaSheet，虽然搜索从被调用的类SpreadSheet本身开始，但它没有提供任何实现，因此调用类  Document 中的getGroup()方法。

## 1.6 异常

异常是从 Exception 类实例化得到的特殊对象。Exception类型的对象用于存放和报告错误信息。
Exception类的构造方法接受两个可选的参数：消息字符串和错误代码

### 1.6.1 抛出异常

可以联合使用 throw 关键字和Exception对象来抛出异常。这会停止执行当前方法，并负责将错误返回给调用代码。
例如：
```php
if (!file_exists($file)) {
	throw new Exception("file is not exitsts");
}
```

抛出异常时，客户端代码怎么知道如何处理异常呢？如果调用可能会抛出异常的方法，那么可以把调用语句放在 try 子句中。try子句由关键字try及其后的括号组成。try 子句必须跟着至少一个 catch 子句才能处理错误

```php
try {
	$conf = new Conf();
	//假如上边的抛出异常是在这个conf() 类里边完成的，如果类里边抛出错误，那么这里是能捕捉到的。
} catch (Exctpiton $e) {
	//根据捕捉到异常进行相应的处理
}
```

### 1.6.2 自定义异常类

所有的自定义异常类都要继承自 Exception 最顶层的异常处理类

class FileException extends Exception {}
class ConfException extends Exception {}

## 1.7 Final 类和方法

继承为类层次内容带来了巨大的灵活性。通过覆写类或方法，根据调用的哪个类实例，调用同样的类方法可以得到完全不同的结果。但有时候，你可能需要类或方法保持不变。如果希望类和方法完成确定不变的功能，担心覆写会它会破坏这个功能，那么需要使用final关键字。

final关键字可以终止类的继承。final类不能有子类，final方法不能被覆写。

## 1.8 使用拦截器

PHP的内置拦截器方法，它可以拦截发送到未定义方法和属性的消息。它也被称为 重载，但是自从这个术语在Java和C++中被赋予不同的含义之后，我认为还是叫做拦截器比较好。

php内置的拦截器方法

| 方法 | 描述 |
| ----- |------|
| __get($property)	| 访问为定义的属性 |
| __set($propert)	| 给未定义的属性赋值时被调用 |
| __isset($propert) | 对未定义的属性调用 isset() 时被调用 |
| __unset($propert) | 对未定义的属性调用 unset() 时被调用 |
| __call($method, $arg_array) | 对未定义的属性调用 unset() 时被调用 |

__get() 和 __set() 方法用于处理类（或其父类）中未声明的属性。
当客服端代码视图访问未声明的属性时，__get() 会被调用，并带一个包含要访问的属性名称字符串参数。无论从 __get() 方法返回了什么，都会发送给客户端代码，就好像带有该值的目标属性存在一样。
```php
class Person {
    function __get($name)
    {
        // TODO: Implement __get() method.
        $method = "get{$name}";
        if (method_exists($this, $method)) {
            return $this->$method;
        }
    }
    function getName() {
        return "Bob";
    }
    function getAge() {
        return 44;
    }
}
```
访问未定义的属性时， __get() 方法被调用。我们实现了 __get() 来获得属性名并构造新的字符串，把 “get” 放在属性名之前，然后将组合成的类方法字符串传给 method_exists() 函数（它接受对象和方法名作为参数），检查方法是否确实存在。如果方法存在，就调用它并把返回值传递给调用者。
$p = new Person();
echo $p->name; //输出
echo $p->gender;//这个方法会不存在，什么也不处理。用户访问的找个熟悉被解析为NULL;

__isset() 和 __get() 方法相似。当客户在一个未定义的属性上调用 isset() 时， __isset()被调用。